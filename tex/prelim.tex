This section provides the background information on which the remainder of the paper will build. First, we present an overview of our reactive controller synthesis process. We refer the reader to \cite{KGFP_TRO09} for a detailed presentation. Then, we briefly present the LTLMoP (Linear Temporal Logic MissiOn Planning) toolkit.

\subsection{Controller Synthesis}\label{preliminariesA}

\subsubsection*{Discrete Abstraction}\label{discreteAbs}

First, the robot's workspace is partitioned using a finite number of cells. The Boolean region propositions $\left\{r_1, r_2, \ldots, r_{N_1} \right\}$ denote the location of the robot in the partition, and are thus mutually exclusive. In addition, the robot can perform actions $\left\{\alpha_1, \alpha_2, \ldots, \alpha_{N_2} \right\}$, which can involve the use of actuators, e.g. grasping an object, turning an on-board camera on, or the activation of memory propositions, e.g. having visited a region at least once. Region and action propositions together form the set of \emph{robot} propositions:
 \begin{equation*}
 	\mathcal{Y} = \left\{ r_1, r_2, \ldots, r_{N_1}, a_1, a_2, \ldots, a_{N_2} \right\}
 \end{equation*}

Furthermore, the robot has sensors, whose value, whether continuous or discrete, is abstracted by the Boolean \emph{environment}/\emph{sensor} propositions $\mathcal{X} = \left\{ x_1, x_2, \ldots, x_{N_3} \right\}$. 
The sensor propositions allow the robot to react to its environment. 
%Together, $\mathcal{X}$ and $\mathcal{Y}$ are the discrete abstraction of the world.

\subsubsection*{Linear Temporal Logic}\label{LTL}

We are interested in missions with complex requirements, such as surveillance, avoidance, and response to events. 
Thus, we use Linear Temporal Logic (LTL) formulas to specify the desired high-level behaviors. LTL consists of Boolean ($\neg, \wedge, \lor$) and temporal (next, $\X$, and until, $\mathcal{U}$) operators. 
Additional temporal operators, eventually, $\F$, and always, $\G$, can be derived. 
In our setting, LTL formulas are constructed from atomic propositions $\pi \in AP = \mathcal{X} \cup \mathcal{Y}$. 
The semantics of an LTL formula $\varphi$ are defined over an infinite sequence $\sigma$ of truth assignments to the atomic propositions. 
Let $t \in \NN$ be the position index of $\sigma$. Then, $\sigma (t)$ is the set of propositions that are true at position $t$ of the sequence $\sigma$. 

\subsubsection*{Reactive Synthesis}\label{GR(1)}
Specifically, we use the GR(1) fragment of LTL, because its synthesis is tractable \cite{piterman_06}. GR(1) formulas have an assume-guarantee structure between the environment ($e$) and the robot (system, $s$):
\begin{align*}
	\varphi &= (\varphi_e \Rightarrow \varphi_s),\\
	\varphi_e &= \varphi_i^e \wedge \varphi_t^e \wedge \varphi_g^e,\\
	\varphi_s &= \varphi_i^s \wedge \varphi_t^s \wedge \varphi_g^s
\end{align*}
where $i$ denotes initial conditions, $t$ safety assumptions/requirements, and $g$ liveness assumptions/requirements (goals) for the environment and the robot, respectively.

For example, to specify the robot task ``starting in region $r_1$, repeatedly visit the region $r_2$ if you are not sensing a fire", we would write: $r_1 \wedge \left(\X(\neg x_{\text{alarm}}) \Rightarrow \G\F r_2 \right)$.

If the formula $\varphi$ is realizable, a discrete robot strategy $\mathcal{S}$ is computed by solving a two-player game between the robot and the environment (adversarial player) \cite{piterman_06}. The strategy, which is guaranteed to be winning for the robot, is augmented with simple low-level controllers to form a hybrid controller \cite{KGFP_TRO09}.

\subsection{LTL Mission Planning}\label{preliminariesB}
% TODO: Rename section to "LTL from Structured English" ?

The Linear Temporal Logic Mission Planner (LTLMoP) \cite{Finucane2010} is a Python-based, open-source toolkit for controlling physical and simulated robots using high-level behavior specifications.\footnote{http://ltlmop.github.io} 
LTLMoP allows users to specify missions in either pure LTL, natural language via a module called SLURP, or a formal grammar called Structured English. Structured English is the most commonly used specification language and will be used for demonstration in this paper. Specifications in Structured English are parsed using a feature-based context-free grammar and translated into formulas of LTL for controller synthesis. 
%END